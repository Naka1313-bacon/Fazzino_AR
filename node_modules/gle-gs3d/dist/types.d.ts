import * as three from 'three';
import { Vector3, Box3, Quaternion, Vector4, DataTexture, Vector2, Mesh, ShaderMaterial, InstancedBufferGeometry, Camera, EventDispatcher, Vector3Tuple, Object3D, Scene, ColorRepresentation, WebGLRenderer, Vector4Tuple, OrthographicCamera, WebGLRenderTarget } from 'three';

declare class Hit {
    distance: number;
    normal: Vector3;
    origin: Vector3;
    constructor();
    set(origin: Vector3, normal: Vector3, distance: number): void;
    clone(): Hit;
}

declare class Ray {
    direction: any;
    origin: any;
    constructor(origin?: Vector3, direction?: Vector3);
    setParameters(origin: Vector3, direction: Vector3): void;
    boxContainsPoint(box: Box3, point: Vector3, epsilon: number): boolean;
    intersectBox: (this: Ray, box: Box3, outHit: Hit) => boolean;
    intersectSphere: (this: Ray, center: Vector3, radius: number, outHit: Hit) => boolean;
}

declare class SplatTreeNode {
    boundingBox: Box3;
    center: Vector3;
    children: SplatTreeNode[];
    data: any;
    depth: number;
    id: any;
    max: Vector3;
    min: Vector3;
    constructor(min: Vector3, max: Vector3, depth: number, id?: any);
}

interface CompressionLevel {
    BytesPerPosition: number;
    BytesPerScale: number;
    BytesPerColor: number;
    BytesPerRotation: number;
    ScaleRange: number;
}
declare class SplatBuffer {
    static PositionComponentCount: number;
    static ScaleComponentCount: number;
    static RotationComponentCount: number;
    static ColorComponentCount: number;
    static CompressionLevels: {
        [index: number]: CompressionLevel;
    };
    static CovarianceSizeFloats: number;
    static CovarianceSizeBytes: number;
    static HeaderSizeBytes: number;
    bucketBlockSize: number;
    bucketCount: number;
    bucketSize: number;
    bucketsBase?: number;
    bytesPerBucket: number;
    bytesPerColor: number;
    bytesPerPosition: number;
    bytesPerRotation: number;
    bytesPerScale: number;
    bytesPerSplat: number;
    colorArray?: Uint8Array;
    compressionLevel: number;
    compressionScaleFactor: number;
    compressionScaleRange: number;
    halfBucketBlockSize: number;
    headerArray: Uint8Array;
    headerBufferData: ArrayBuffer;
    positionArray?: Float32Array | Uint16Array;
    precomputedCovarianceBufferData: ArrayBuffer | null;
    rotationArray?: Float32Array | Uint16Array;
    scaleArray?: Float32Array | Uint16Array;
    splatBufferData: ArrayBuffer;
    splatCount: number;
    constructor(bufferData: ArrayBuffer);
    linkBufferArrays(): void;
    fbf(f: any): any;
    tbf(f: any): any;
    buildPreComputedBuffers(): void;
    getHeaderBufferData(): ArrayBuffer;
    getSplatBufferData(): ArrayBuffer;
    getPosition(index: number, outPosition?: Vector3): Vector3;
    setPosition(index: number, position: Vector3): void;
    getScale(index: number, outScale?: Vector3): Vector3;
    setScale(index: number, scale: Vector3): void;
    getRotation(index: number, outRotation?: Quaternion): Quaternion;
    setRotation(index: number, rotation: Quaternion): void;
    getColor(index: number, outColor?: Vector4): Vector4;
    setColor(index: number, color: Vector4): void;
    getPrecomputedCovarianceBufferData(): ArrayBuffer | null;
    getSplatCount(): number;
    fillPositionArray(outPositionArray: Float32Array | Uint16Array): void;
    fillScaleArray(outScaleArray: Float32Array | Uint16Array): void;
    fillRotationArray(outRotationArray: Float32Array | Uint16Array): void;
    fillColorArray(outColorArray: Uint8Array): void;
    swapVertices(indexA: number, indexB: number): void;
}

declare class SplatTree {
    addedIndexes: any;
    maxDepth: number;
    maxPositionsPerNode: number;
    nodesWithIndexes: SplatTreeNode[];
    rootNode: SplatTreeNode | null;
    sceneDimensions: any;
    sceneMax: any;
    sceneMin: any;
    splatBuffer: any;
    constructor(maxDepth: number, maxPositionsPerNode: number);
    processSplatBuffer(splatBuffer: SplatBuffer, filterFunc?: (splatIndex?: number) => boolean): void;
    processNode(node: SplatTreeNode, splatBuffer: SplatBuffer): void;
    countLeaves(): number;
    visitLeaves(visitFunc: any): void;
}

interface SpatDataTextureCovariances {
    data: Float32Array | Uint16Array;
    texture: DataTexture;
    size: Vector2;
}
interface SplatDataTextureCenterColors {
    data: Uint32Array;
    texture: DataTexture;
    size: Vector2;
}
interface SplatDataTextures {
    covariances: SpatDataTextureCovariances;
    centerColors: SplatDataTextureCenterColors;
}

declare class SplatMesh extends Mesh {
    centerColors?: Uint32Array;
    centers?: Float32Array;
    colors?: Uint8Array;
    covariances?: Float32Array;
    halfPrecisionCovariancesOnGPU: boolean;
    splatAlphaRemovalThreshold: number;
    splatBuffer: SplatBuffer;
    splatDataTextures: SplatDataTextures | null;
    splatTree: SplatTree | null;
    shaderMaterial: ShaderMaterial;
    instancedBufferGeometry: InstancedBufferGeometry;
    static buildMesh(splatBuffer: SplatBuffer, splatAlphaRemovalThreshold?: number, halfPrecisionCovariancesOnGPU?: boolean): SplatMesh;
    constructor(splatBuffer: SplatBuffer, geometry: InstancedBufferGeometry, material: ShaderMaterial, splatAlphaRemovalThreshold?: number, halfPrecisionCovariancesOnGPU?: boolean);
    static buildMaterial(): ShaderMaterial;
    static buildGeometry(splatBuffer: any): InstancedBufferGeometry;
    buildSplatTree(): void;
    getSplatTree(): SplatTree | null;
    resetLocalSplatDataAndTexturesFromSplatBuffer(): void;
    updateLocalSplatDataFromSplatBuffer(): void;
    allocateAndStoreLocalSplatDataInTextures(): void;
    updateSplatDataToDataTextures(): void;
    updateLocalCovarianceDataToDataTexture(): void;
    updateLocalCenterColorDataToDataTexture(): void;
    updateIndexes(indexes: Uint32Array, renderSplatCount: number): void;
    updateUniforms(renderDimensions: Vector2, cameraFocalLength: number): void;
    getSplatDataTextures(): SplatDataTextures | null;
    getSplatCount(): number;
    getCenters(): Float32Array | undefined;
    getColors(): Uint8Array | undefined;
    getCovariances(): Float32Array | undefined;
}

declare class Raycaster {
    ray: Ray;
    private camera;
    constructor(origin?: Vector3, direction?: Vector3);
    setFromCameraAndScreenPosition: (this: Raycaster, camera: Camera, screenPosition: Vector2, screenDimensions: Vector2) => void;
    intersectSplatMesh: (this: Raycaster, splatMesh: SplatMesh, outHits?: Hit[]) => Hit[];
    castRayAtSplatTreeNode: (this: Raycaster, ray: Ray, splatTree: SplatTree, node: SplatTreeNode, outHits?: Hit[]) => Hit[] | undefined;
}

declare function createSortWorker(splatCount: any): Worker;

declare class Constants {
    static DepthMapRange: number;
    static MemoryPageSize: number;
    static BytesPerFloat: number;
    static BytesPerInt: number;
}

declare class LoadingSpinner {
    message: string;
    messageDiv: HTMLDivElement;
    spinnerDiv: HTMLDivElement;
    spinnerDivContainer: HTMLDivElement;
    constructor(message?: string);
    show(): void;
    hide(): void;
    setMessage(msg: string): void;
}

declare class OrbitControls extends EventDispatcher<any> {
    _domElementKeyEvents: any;
    autoRotate: any;
    autoRotateSpeed: any;
    dampingFactor: any;
    dispose: any;
    domElement: any;
    enableDamping: any;
    enablePan: any;
    enableRotate: any;
    enableZoom: any;
    enabled: any;
    getAzimuthalAngle: any;
    getDistance: any;
    getPolarAngle: any;
    keyPanSpeed: any;
    keys: any;
    listenToKeyEvents: any;
    maxAzimuthAngle: any;
    maxDistance: any;
    maxPolarAngle: any;
    maxZoom: any;
    minAzimuthAngle: any;
    minDistance: any;
    minPolarAngle: any;
    minZoom: any;
    mouseButtons: any;
    object: any;
    panSpeed: any;
    position0: any;
    reset: any;
    rotateSpeed: any;
    saveState: any;
    screenSpacePanning: any;
    stopListenToKeyEvents: any;
    target: any;
    target0: any;
    touches: any;
    update: any;
    zoom0: any;
    zoomSpeed: any;
    zoomToCursor: any;
    constructor(object: any, domElement: any);
}

declare class PlyLoader {
    splatBuffer: SplatBuffer | null;
    constructor();
    fetchFile(fileName: string, onProgress: (progress: number, progressMessage: string, chunk?: Uint8Array) => void): Promise<ArrayBuffer>;
    loadFromFile(fileName: string, onProgress: (progress: number, progressMessage: string, chunk?: Uint8Array) => void, compressionLevel?: number, minimumAlpha?: number): Promise<SplatBuffer>;
}

interface SplatBucket {
    'splats': number[];
    'center': Vector3Tuple;
}
declare class PlyParser {
    plyBuffer: ArrayBuffer;
    constructor(plyBuffer: ArrayBuffer);
    decodeHeader(plyBuffer: ArrayBuffer): {
        splatCount: number;
        propertyTypes: {
            [propertyName: string]: string;
        };
        vertexData: DataView;
        headerOffset: number;
    };
    readRawVertexFast(vertexData: DataView, offset: number, fieldOffsets: {
        [fieldName: string]: number;
    }, propertiesToRead: string[], propertyTypes: {
        [propertyName: string]: string;
    }, outVertex: any): void;
    parseToSplatBuffer(compressionLevel?: number, minimumAlpha?: number): SplatBuffer;
    computeBuckets(positions: any): SplatBucket[];
}

declare class SceneHelper {
    debugRoot?: Object3D;
    meshCursor: Object3D | null;
    scene: Scene;
    secondaryDebugRoot?: Object3D;
    simpleScene: Scene;
    constructor(scene: Scene, simpleScene: Scene);
    setupMeshCursor(): void;
    destroyMeshCursor(): void;
    setMeshCursorVisibility(visible: boolean): void;
    setMeshCursorPosition(position: Vector3): void;
    positionAndOrientMeshCursor(position: Vector3, camera: Camera): void;
    addDebugMeshes(): void;
    createDebugMeshes(renderOrder?: number): Object3D<three.Object3DEventMap>;
    createSecondaryDebugMeshes(renderOrder?: number): Object3D<three.Object3DEventMap>;
    static buildDebugMaterial(color: ColorRepresentation): ShaderMaterial;
}

declare class SplatLoader {
    downLoadLink: HTMLAnchorElement | null;
    splatBuffer: SplatBuffer | null;
    constructor(splatBuffer?: null);
    loadFromFile(fileName: string, onProgress: (progress: number, progressMessage: string, chunk?: Uint8Array) => void): Promise<SplatBuffer>;
    setFromBuffer(splatBuffer: SplatBuffer): void;
    saveToFile(fileName: string): void;
}

declare const floatToHalf: (val: number) => number;
declare const uintEncodedFloat: (f: number) => number;
declare const rgbaToInteger: (r: number, g: number, b: number, a: number) => number;
declare const fetchWithProgress: (path: any, onProgress: (progress: number, progressMessage: string, chunk?: Uint8Array) => void) => Promise<ArrayBuffer>;
declare const clamp: (val: number, min: number, max: number) => number;

interface ViewerParams {
    cameraUp?: Vector3Tuple;
    initialCameraPosition?: Vector3Tuple;
    initialCameraLookAt?: Vector3Tuple;
    selfDrivenMode?: boolean;
    useBuiltInControls?: boolean;
    scene?: Scene;
    simpleScene?: Scene;
    renderer?: WebGLRenderer;
    camera?: Camera;
    rootElement?: HTMLDivElement;
}
interface LoadFileOptions {
    position?: Vector3Tuple;
    positionVector?: Vector3;
    orientation?: Vector4Tuple;
    orientationQuaternion?: Quaternion;
    splatAlphaRemovalThreshold?: number;
    halfPrecisionCovariancesOnGPU?: boolean;
}

declare class Viewer {
    camera?: Camera;
    cameraFocalLength?: number;
    cameraUp: Vector3;
    controls: OrbitControls | null;
    currentFPS: number;
    inIndexArray: Uint32Array | null;
    infoPanel: HTMLDivElement | null;
    infoPanelCells: {
        [id: string]: HTMLDivElement;
    };
    initialCameraLookAt: Vector3;
    initialCameraPosition: Vector3;
    lastSortTime: number;
    mousePosition: Vector2;
    outIndexArray?: Uint32Array;
    raycaster: Raycaster;
    renderTargetCopyCamera?: OrthographicCamera;
    renderTargetCopyMaterial?: ShaderMaterial;
    renderTargetCopyQuad?: Mesh;
    renderer?: WebGLRenderer;
    rootElement?: HTMLDivElement;
    scene?: Scene;
    sceneHelper: SceneHelper | null;
    selfDrivenMode: boolean;
    selfDrivenModeRunning: boolean;
    selfDrivenUpdateFunc: () => void;
    showInfo: boolean;
    showMeshCursor: boolean;
    simpleObjectDepthOverrideMaterial?: ShaderMaterial;
    simpleScene?: Scene;
    sortRunning: boolean;
    sortWorker: Worker | null;
    splatMesh: SplatMesh | null;
    splatRenderCount: number;
    splatRenderTarget?: WebGLRenderTarget;
    splatRenderingInitialized: boolean;
    splatSortCount: number;
    useBuiltInControls: boolean;
    usingExternalCamera: boolean;
    usingExternalRenderer: boolean;
    constructor(params?: ViewerParams);
    onKeyDown(e: any): void;
    onMouseMove(mouse: any): void;
    getRenderDimensions(outDimensions: Vector2): void;
    init(): void;
    setupInfoPanel(): void;
    updateSplatRenderTargetForRenderDimensions(width: number, height: number): void;
    setupSimpleObjectDepthOverrideMaterial(): void;
    setupRenderTargetCopyObjects(): void;
    updateSplatMeshUniforms: (this: Viewer) => void;
    loadFile(fileName: string, options?: LoadFileOptions): Promise<void>;
    setupSplatMesh(splatBuffer: any, splatAlphaRemovalThreshold?: number, position?: Vector3, quaternion?: Quaternion, halfPrecisionCovariancesOnGPU?: boolean): void;
    setupSortWorker(splatBuffer: SplatBuffer): Promise<void>;
    gatherSceneNodes: (this: Viewer, gatherAllNodes: any) => void;
    start(): void;
    updateFPS: (this: Viewer) => void;
    updateForRendererSizeChanges: (this: Viewer) => void;
    selfDrivenUpdate(): void;
    update(): void;
    rayCastScene: (this: Viewer) => void;
    updateInfo: (this: Viewer) => void;
    render(): void;
    updateView: (this: Viewer, force?: boolean, gatherAllNodes?: boolean) => void;
    getSplatMesh(): SplatMesh | null;
}

export { Constants, Hit, type LoadFileOptions, LoadingSpinner, OrbitControls, PlyLoader, PlyParser, Ray, Raycaster, SceneHelper, SplatBuffer, SplatLoader, SplatMesh, SplatTree, SplatTreeNode, Viewer, type ViewerParams, clamp, createSortWorker, fetchWithProgress, floatToHalf, rgbaToInteger, uintEncodedFloat };
